<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>NamespaceTrie.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Fences Enforcer Rule</a> &gt; <a href="index.source.html" class="el_package">com.google.security.fences.namespace</a> &gt; <span class="el_source">NamespaceTrie.java</span></div><h1>NamespaceTrie.java</h1><pre class="source lang-java linenums">package com.google.security.fences.namespace;

import java.util.Map;
import java.util.SortedMap;
import java.util.TreeMap;

import com.google.common.base.Function;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.base.Supplier;
import com.google.common.collect.ImmutableMap;

/**
 * Maps package and class names to values.
 *
 * @param &lt;COMPLEX_VALUE&gt; The value type stored at a Trie node.
 * @param &lt;SIMPLE_VALUE&gt; The type that can be added to a Trie node.
 *    This can be a part of the COMPLEX_VALUE allowing the trie to easily
 *    function as a MultiTrie.
 */
public final class NamespaceTrie&lt;SIMPLE_VALUE, COMPLEX_VALUE&gt; {
<span class="fc" id="L22">  final Entry&lt;COMPLEX_VALUE&gt; root = new Entry&lt;COMPLEX_VALUE&gt;(null);</span>
  final Supplier&lt;COMPLEX_VALUE&gt; makeEmpty;
  final Function&lt;COMPLEX_VALUE, Function&lt;SIMPLE_VALUE, COMPLEX_VALUE&gt;&gt; folder;

  /**
   * @param makeEmpty a supplier for empty complex values.
   * @param folder combines a previous complex value and a simple value being
   *    added to a node together to produce the new complex value.
   */
  public NamespaceTrie(
      Supplier&lt;COMPLEX_VALUE&gt; makeEmpty,
<span class="fc" id="L33">      Function&lt;COMPLEX_VALUE, Function&lt;SIMPLE_VALUE, COMPLEX_VALUE&gt;&gt; folder) {</span>
<span class="fc" id="L34">    this.makeEmpty = makeEmpty;</span>
<span class="fc" id="L35">    this.folder = folder;</span>
<span class="fc" id="L36">  }</span>

  /** The minimal collection of entries that includes all overlapping ns. */
  public Map&lt;Namespace, COMPLEX_VALUE&gt; overlapping(Namespace ns) {
<span class="nc" id="L40">    Entry&lt;COMPLEX_VALUE&gt; e = getEntry(ns, false, false);</span>
    ImmutableMap.Builder&lt;Namespace, COMPLEX_VALUE&gt; b =
<span class="nc" id="L42">        ImmutableMap.builder();</span>
<span class="nc bnc" id="L43" title="All 2 branches missed.">    if (e != null) {</span>
<span class="nc" id="L44">      e.addTransitively(ns, b);</span>
    }
<span class="nc" id="L46">    return b.build();</span>
  }

  /**
   * The node specified by the given namespace if any.
   */
  public Entry&lt;COMPLEX_VALUE&gt; get(Namespace ns) {
<span class="nc" id="L53">    return getEntry(ns, false, false);</span>
  }

  /**
   * Folds a simple value into the node specified by ns,
   * creating a new node if necessary.
   */
  public Entry&lt;COMPLEX_VALUE&gt; put(Namespace ns, SIMPLE_VALUE simpleValue) {
<span class="fc" id="L61">    Entry&lt;COMPLEX_VALUE&gt; e = Preconditions.checkNotNull(</span>
<span class="fc" id="L62">        getEntry(ns, true, false));</span>
<span class="fc" id="L63">    e.putValue(this.makeEmpty, this.folder, simpleValue);</span>
<span class="fc" id="L64">    return e;</span>
  }

  /**
   * The value at namespace or one of its ancestors giving preferences to
   * deeper nodes.
   */
  public Entry&lt;COMPLEX_VALUE&gt; getDeepest(Namespace ns) {
<span class="fc" id="L72">    return getEntry(ns, false, true);</span>
  }

  private Entry&lt;COMPLEX_VALUE&gt; getEntry(
      Namespace ns, boolean manufacture, boolean bestEffort) {
    Entry&lt;COMPLEX_VALUE&gt; parentEntry;
<span class="fc" id="L78">    Optional&lt;Namespace&gt; parent = ns.getParent();</span>
<span class="fc bfc" id="L79" title="All 2 branches covered.">    if (parent.isPresent()) {</span>
<span class="fc" id="L80">      parentEntry = getEntry(parent.get(), manufacture, bestEffort);</span>
<span class="pc bpc" id="L81" title="1 of 2 branches missed.">      if (parentEntry == null) { return null; }</span>
    } else {
<span class="fc" id="L83">      parentEntry = root;</span>
    }
<span class="fc" id="L85">    Optional&lt;String&gt; nameOpt = ns.getName();</span>
<span class="fc bfc" id="L86" title="All 2 branches covered.">    if (nameOpt.isPresent()) {</span>
<span class="fc" id="L87">      String name = nameOpt.get();</span>
      @SuppressWarnings(&quot;synthetic-access&quot;)
<span class="fc" id="L89">      SortedMap&lt;String, Entry&lt;COMPLEX_VALUE&gt;&gt; children = parentEntry.children;</span>
<span class="fc" id="L90">      Entry&lt;COMPLEX_VALUE&gt; child = children.get(name);</span>
<span class="fc bfc" id="L91" title="All 2 branches covered.">      if (child == null) {</span>
<span class="fc bfc" id="L92" title="All 2 branches covered.">        if (manufacture) {</span>
<span class="fc" id="L93">          child = new Entry&lt;COMPLEX_VALUE&gt;(parentEntry);</span>
<span class="fc" id="L94">          children.put(name, child);</span>
<span class="pc bpc" id="L95" title="1 of 2 branches missed.">        } else if (bestEffort) {</span>
<span class="fc" id="L96">          return parentEntry;</span>
        }
      }
<span class="fc" id="L99">      return child;</span>
    } else {
<span class="fc" id="L101">      return parentEntry;</span>
    }
  }

  /**
   * A diagnostic text representation of the trie with one line per entry.
   */
  public String toTree() {
<span class="nc" id="L109">    return root.toTree();</span>
  }


  /** A trie entry. */
  public static final class Entry&lt;T&gt; {
<span class="fc" id="L115">    private Optional&lt;T&gt; value = Optional.absent();</span>
    private final Entry&lt;T&gt; parent;
<span class="fc" id="L117">    private final SortedMap&lt;String, Entry&lt;T&gt;&gt; children =</span>
        new TreeMap&lt;String, Entry&lt;T&gt;&gt;();

<span class="fc" id="L120">    Entry(Entry&lt;T&gt; parent) {</span>
<span class="fc" id="L121">      this.parent = parent;</span>
<span class="fc" id="L122">    }</span>

    &lt;X&gt;
    void putValue(
        Supplier&lt;T&gt; emptyValue, Function&lt;T, Function&lt;X, T&gt;&gt; fold,
        X newValuePart) {
<span class="fc" id="L128">      T newValue = fold.apply(value.or(emptyValue)).apply(newValuePart);</span>
<span class="fc" id="L129">      value = Optional.of(newValue);</span>
<span class="fc" id="L130">    }</span>

    /** The value if any is specified. */
    public Optional&lt;T&gt; getValue() {
<span class="fc" id="L134">      return value;</span>
    }

    /** The parent entry or absent if this entry is the root of the trie. */
    public Optional&lt;Entry&lt;T&gt;&gt; getParent() {
<span class="fc" id="L139">      return Optional.fromNullable(parent);</span>
    }

    void addTransitively(Namespace ns, ImmutableMap.Builder&lt;Namespace, T&gt; out) {
<span class="nc bnc" id="L143" title="All 2 branches missed.">      if (value.isPresent()) {</span>
<span class="nc" id="L144">        out.put(ns, value.get());</span>
      }
<span class="nc bnc" id="L146" title="All 2 branches missed.">      for (Map.Entry&lt;String, Entry&lt;T&gt;&gt; e : children.entrySet()) {</span>
<span class="nc" id="L147">        e.getValue().addTransitively(ns.child(e.getKey()), out);</span>
<span class="nc" id="L148">      }</span>
<span class="nc" id="L149">    }</span>

    @Override
    public String toString() {
<span class="nc" id="L153">      return toShallowString();</span>
    }

    String toShallowString() {
<span class="nc" id="L157">      return &quot;Entry &quot; + value;</span>
    }

    /** A diagnostic string containing the entry in indented tree form. */
    public String toTree() {
<span class="nc" id="L162">      StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L163">      toTree(sb, 0);</span>
<span class="nc" id="L164">      return sb.toString();</span>
    }

    /**
     * Appends a diagnostic string containing the entry in indented tree form.
     *
     * @param sb receives the text of the tree
     * @param n the indentation level.
     */
    public void toTree(StringBuilder sb, int n) {
<span class="nc" id="L174">      sb.append(toShallowString());</span>
<span class="nc" id="L175">      int childDepth = n + 1;</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">      for (Map.Entry&lt;String, Entry&lt;T&gt;&gt; e : children.entrySet()) {</span>
<span class="nc" id="L177">        sb.append('\n');</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">        for (int i = childDepth; --i &gt;= 0;) { sb.append(&quot;. &quot;); }</span>
<span class="nc" id="L179">        sb.append(e.getKey()).append(&quot; =&gt; &quot;);</span>
<span class="nc" id="L180">        e.getValue().toTree(sb, childDepth);</span>
<span class="nc" id="L181">      }</span>
<span class="nc" id="L182">    }</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>