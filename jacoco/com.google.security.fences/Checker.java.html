<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Checker.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Fences Enforcer Rule</a> &gt; <a href="index.source.html" class="el_package">com.google.security.fences</a> &gt; <span class="el_source">Checker.java</span></div><h1>Checker.java</h1><pre class="source lang-java linenums">package com.google.security.fences;

import java.io.IOException;
import java.util.List;
import java.util.Map;

import org.apache.maven.artifact.Artifact;
import org.apache.maven.enforcer.rule.api.EnforcerRuleException;
import org.apache.maven.plugin.logging.Log;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.Handle;
import org.objectweb.asm.Label;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;

import com.google.common.base.Optional;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.security.fences.config.Rationale;
import com.google.security.fences.inheritance.InheritanceGraph;
import com.google.security.fences.namespace.Namespace;
import com.google.security.fences.policy.AccessLevel;
import com.google.security.fences.policy.ApiElement;
import com.google.security.fences.policy.ApiElementType;
import com.google.security.fences.policy.Policy;
import com.google.security.fences.policy.PolicyApplicationOrder;
import com.google.security.fences.util.LazyString;
import com.google.security.fences.util.Utils;

/**
 * Given a bundle of class files, checks each &quot;.class&quot; file against a policy.
 */
final class Checker extends AbstractClassesVisitor {
  final Log log;
  final Policy policy;
  final InheritanceGraph inheritanceGraph;
<span class="nc" id="L39">  private final List&lt;Violation&gt; violations =</span>
<span class="nc" id="L40">      Lists.newArrayList();</span>

<span class="nc" id="L42">  Checker(Log log, InheritanceGraph inheritanceGraph, Policy policy) {</span>
<span class="nc" id="L43">    this.log = log;</span>
<span class="nc" id="L44">    this.inheritanceGraph = inheritanceGraph;</span>
<span class="nc" id="L45">    this.policy = policy;</span>
<span class="nc" id="L46">  }</span>

  /**
   * @return the count of errors logged.
   *     Greater than zero if there were one or more policy violations.
   */
  ImmutableList&lt;Violation&gt; getViolations() {
<span class="nc" id="L53">    return ImmutableList.copyOf(violations);</span>
  }

  @Override
  protected void startClassRoot(ClassRoot root) {
<span class="nc" id="L58">    log.debug(&quot;Visiting &quot; + root);</span>
<span class="nc" id="L59">  }</span>

  @Override
  protected ClassVisitor makeVisitorForClass(
      ClassRoot root, String relPath, ClassReader reader)
  throws IOException {
    try {
<span class="nc" id="L66">      return new ClassChecker(root.art, reader);</span>
<span class="nc" id="L67">    } catch (EnforcerRuleException ex) {</span>
<span class="nc" id="L68">      throw new IOException(&quot;Failed to check &quot; + root, ex);</span>
    }
  }

  final class ClassChecker extends ClassVisitor {
    final Artifact art;
    final ClassReader reader;
    final String className;
    final Namespace ns;
<span class="nc" id="L77">    private Optional&lt;String&gt; sourceFilePath = Optional.absent();</span>

    ClassChecker(Artifact art, ClassReader reader)
<span class="nc" id="L80">    throws EnforcerRuleException {</span>
<span class="nc" id="L81">      super(Opcodes.ASM5);</span>
<span class="nc" id="L82">      this.art = art;</span>
<span class="nc" id="L83">      this.reader = reader;</span>
<span class="nc" id="L84">      this.className = reader.getClassName();</span>
<span class="nc" id="L85">      this.ns = Namespace.fromInternalClassName(className);</span>
<span class="nc" id="L86">    }</span>

    @Override
    public void visit(
        int version, int access, String name, String signature,
        String superName, String[] interfaces) {
<span class="nc" id="L92">      log.debug(&quot;. Visiting class &quot; + className);</span>
<span class="nc" id="L93">    }</span>

    @Override
    public void visitSource(String source, String debug) {
<span class="nc" id="L97">      this.sourceFilePath = Optional.fromNullable(source);</span>
<span class="nc" id="L98">    }</span>

    @Override
    public MethodVisitor visitMethod(
        int access, String name, String desc, String signature,
        String[] exceptions) {
<span class="nc" id="L104">      return new MethodChecker(art, reader, sourceFilePath, ns, name);</span>
    }
  }

  private final class MethodChecker extends MethodVisitor {
    final Artifact art;
    final Optional&lt;String&gt; sourceFilePath;
    final String className;
    final Namespace ns;
    final String methodName;
<span class="nc" id="L114">    private final Map&lt;ApiElement, Map&lt;String, PolicyResult&gt;&gt; memoTable =</span>
<span class="nc" id="L115">        Maps.newLinkedHashMap();</span>
<span class="nc" id="L116">    private int latestLineNumber = -1;</span>

    MethodChecker(
        Artifact art, ClassReader reader, Optional&lt;String&gt; sourceFilePath,
<span class="nc" id="L120">        Namespace ns, String methodName) {</span>
<span class="nc" id="L121">      super(Opcodes.ASM5);</span>
<span class="nc" id="L122">      this.art = art;</span>
<span class="nc" id="L123">      this.sourceFilePath = sourceFilePath;</span>
<span class="nc" id="L124">      this.className = reader.getClassName();</span>
<span class="nc" id="L125">      this.ns = ns;</span>
<span class="nc" id="L126">      this.methodName = methodName;</span>
<span class="nc" id="L127">    }</span>

    @Override
    public void visitCode() {
<span class="nc" id="L131">      log.debug(&quot;. . Visiting method &quot; + methodName);</span>
<span class="nc" id="L132">    }</span>

    @Override
    public void visitFieldInsn(
        int opcode, String owner, String name, String desc) {
<span class="nc" id="L137">      ApiElement classEl = ApiElement.fromInternalClassName(owner);</span>
<span class="nc" id="L138">      ApiElement fieldApiElement = classEl.child(name, ApiElementType.FIELD);</span>
<span class="nc" id="L139">      requireAccessAllowed(fieldApiElement, desc);</span>
<span class="nc" id="L140">    }</span>

    @Override
    public void visitInvokeDynamicInsn(
        String name, String desc, Handle bsm, Object... bsmArgs) {
      // TODO: Should we do some kind of worst-case analysis here?
<span class="nc" id="L146">    }</span>

    @Override
    public void visitMethodInsn(
        int opcode, String owner, String name, String desc, boolean itf) {
<span class="nc" id="L151">      ApiElement classEl = ApiElement.fromInternalClassName(owner);</span>
<span class="nc" id="L152">      ApiElement methodApiElement = classEl.child(</span>
          name,
<span class="nc bnc" id="L154" title="All 2 branches missed.">          ApiElement.CONSTRUCTOR_SPECIAL_METHOD_NAME.equals(name)</span>
          ? ApiElementType.CONSTRUCTOR : ApiElementType.METHOD);
<span class="nc" id="L156">      requireAccessAllowed(methodApiElement, desc);</span>
<span class="nc" id="L157">    }</span>

    @Override
    public void visitLineNumber(int lineNumber, Label start) {
      // Keep track of line number hints so we can include those in
      // error messages.
<span class="nc" id="L163">      this.latestLineNumber = lineNumber;</span>
<span class="nc" id="L164">    }</span>

    /**
     * Applies the policy and makes any violation available to
     * {@link Checker#getViolations()}.
     */
    @SuppressWarnings(&quot;synthetic-access&quot;)
    void requireAccessAllowed(final ApiElement el, String descriptor) {
<span class="nc" id="L172">      Map&lt;String, PolicyResult&gt; descriptorMemoTable = memoTable.get(el);</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">      if (descriptorMemoTable == null) {</span>
<span class="nc" id="L174">        descriptorMemoTable = Maps.newLinkedHashMap();</span>
<span class="nc" id="L175">        memoTable.put(el, descriptorMemoTable);</span>
      }
<span class="nc" id="L177">      PolicyResult r = descriptorMemoTable.get(descriptor);</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">      if (r == null) {</span>
<span class="nc" id="L179">        log.debug(new LazyString() {</span>
          @Override
          protected String makeString() {
<span class="nc" id="L182">            return &quot;. . . Checking whether &quot; + el + &quot; allowed from &quot; + ns</span>
<span class="nc" id="L183">                + &quot; in &quot; + Utils.artToString(art);</span>
          }
        });
<span class="nc" id="L186">        r = Checker.this.applyAccessPolicy(ns, el, descriptor);</span>
<span class="nc" id="L187">        descriptorMemoTable.put(descriptor, r);</span>
      }
<span class="nc bnc" id="L189" title="All 3 branches missed.">      switch (r.accessLevel) {</span>
        case ALLOWED:
<span class="nc" id="L191">          return;</span>
        case DISALLOWED:
<span class="nc" id="L193">          Violation v = new Violation(</span>
              art,
              ns,
<span class="nc" id="L196">              sourceFilePath.or(className),</span>
              latestLineNumber,
              el,
              r.target,
              r.rationale);
<span class="nc" id="L201">          Checker.this.violations.add(v);</span>
<span class="nc" id="L202">          return;</span>
      }
<span class="nc" id="L204">      throw new AssertionError(r.accessLevel);</span>
    }
  }

  static final class PolicyResult {
    /** The policy decision. */
    final AccessLevel accessLevel;
    /** The rationale for the decision. */
    final Rationale rationale;
    /**
     * The API element based upon which the decision was made.
     * This may be an API element defined on an ancestor of the
     * element accessed in code defined in the trusted/distrusted namespace.
     */
    final ApiElement target;

    static PolicyResult defaultResult(ApiElement target) {
<span class="nc" id="L221">      return new PolicyResult(</span>
        AccessLevel.ALLOWED,  // Default to plain old Java rules.
        Rationale.EMPTY,
        target);
    }

    PolicyResult(
<span class="nc" id="L228">        AccessLevel accessLevel, Rationale rationale, ApiElement target) {</span>
<span class="nc" id="L229">      this.accessLevel = accessLevel;</span>
<span class="nc" id="L230">      this.rationale = rationale;</span>
<span class="nc" id="L231">      this.target = target;</span>
<span class="nc" id="L232">    }</span>
  }

  PolicyResult applyAccessPolicy(
      Namespace from, ApiElement to, String descriptor) {
    // Find the most-specific rationale.
<span class="nc" id="L238">    Iterable&lt;Policy.NamespacePolicy&gt; applicable = policy.forNamespace(from);</span>

    for (ApiElement el :
<span class="nc bnc" id="L241" title="All 2 branches missed.">         new PolicyApplicationOrder(to, descriptor, inheritanceGraph, log)) {</span>
<span class="nc" id="L242">      AccessLevel levelFromPolicy = null;</span>
<span class="nc" id="L243">      Rationale.Builder rationaleBuilder = new Rationale.Builder();</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">      for (Policy.NamespacePolicy nsp : applicable) {</span>
<span class="nc" id="L245">        Optional&lt;Policy.AccessControlDecision&gt; d =</span>
<span class="nc" id="L246">            nsp.accessPolicyForApiElement(el);</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">        if (d.isPresent()) {</span>
<span class="nc" id="L248">          Policy.AccessControlDecision acd = d.get();</span>
<span class="nc" id="L249">          AccessLevel dLvl = acd.accessLevel;</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">          if (levelFromPolicy == null) {</span>
<span class="nc" id="L251">            levelFromPolicy = dLvl;</span>
          }
<span class="nc bnc" id="L253" title="All 4 branches missed.">          if (dLvl == levelFromPolicy &amp;&amp; !acd.rationale.isEmpty()) {</span>
            try {
<span class="nc" id="L255">              rationaleBuilder.addBody(acd.rationale);</span>
<span class="nc" id="L256">            } catch (EnforcerRuleException ex) {</span>
              // Should not happen since this came from a rationale.
<span class="nc" id="L258">              throw new AssertionError(null, ex);</span>
<span class="nc" id="L259">            }</span>
            break;
          }
        }
<span class="nc" id="L263">      }</span>

      try {
<span class="nc" id="L266">        rationaleBuilder.addAddendum(policy.getAddenda(to));</span>
<span class="nc" id="L267">      } catch (EnforcerRuleException ex) {</span>
        // Should not happen since this came from a rationale.
<span class="nc" id="L269">        throw new AssertionError(null, ex);</span>
<span class="nc" id="L270">      }</span>

<span class="nc bnc" id="L272" title="All 2 branches missed.">      if (levelFromPolicy != null) {</span>
<span class="nc" id="L273">        return new PolicyResult(</span>
            // Default to java rules.
            levelFromPolicy,
<span class="nc" id="L276">            rationaleBuilder.build(),</span>
            el);
      }
<span class="nc" id="L279">    }</span>
<span class="nc" id="L280">    return PolicyResult.defaultResult(to);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>