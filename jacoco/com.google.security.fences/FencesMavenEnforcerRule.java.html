<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>FencesMavenEnforcerRule.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Fences Rule</a> &gt; <a href="index.source.html" class="el_package">com.google.security.fences</a> &gt; <span class="el_source">FencesMavenEnforcerRule.java</span></div><h1>FencesMavenEnforcerRule.java</h1><pre class="source lang-java linenums">package com.google.security.fences;

import org.apache.maven.artifact.Artifact;
import org.apache.maven.artifact.repository.ArtifactRepository;
import org.apache.maven.artifact.resolver.ArtifactNotFoundException;
import org.apache.maven.artifact.resolver.ArtifactResolutionException;
import org.apache.maven.artifact.resolver.ArtifactResolver;
import org.apache.maven.enforcer.rule.api.EnforcerRule;
import org.apache.maven.enforcer.rule.api.EnforcerRuleException;
import org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;
import org.apache.maven.plugin.logging.Log;
import org.apache.maven.project.MavenProject;
import org.apache.maven.shared.dependency.tree.DependencyTreeBuilder;
import org.apache.maven.shared.dependency.tree.DependencyTreeBuilderException;
import org.codehaus.plexus.component.configurator.BasicComponentConfigurator;
import org.codehaus.plexus.component.configurator.ComponentConfigurator;
import org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;
import org.codehaus.plexus.component.repository.exception.ComponentLookupException;
import org.codehaus.plexus.interpolation.PropertiesBasedValueSource;
import org.w3c.dom.Element;

import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;
import com.google.common.hash.HashCode;
import com.google.common.hash.HashFunction;
import com.google.common.hash.Hashing;
import com.google.common.io.ByteSink;
import com.google.common.io.ByteSource;
import com.google.common.io.Files;
import com.google.security.fences.RecordingLog.Entry;
import com.google.security.fences.checker.Checker;
import com.google.security.fences.classpath.ArtifactFinder;
import com.google.security.fences.classpath.ClassRoot;
import com.google.security.fences.classpath.ConfigurationImport;
import com.google.security.fences.config.ApiFence;
import com.google.security.fences.config.ClassFence;
import com.google.security.fences.config.Fence;
import com.google.security.fences.config.PackageFence;
import com.google.security.fences.inheritance.InheritanceGraph;
import com.google.security.fences.inheritance.InheritanceGraphExtractor;
import com.google.security.fences.policy.ApiElement;
import com.google.security.fences.policy.Policy;
import com.google.security.fences.reporting.PolicyViolationReporter;
import com.google.security.fences.reporting.Violation;
import com.google.security.fences.util.LazyString;
import com.google.security.fences.util.MisconfigurationException;
import com.google.security.fences.util.RelevantSystemProperties;
import com.google.security.fences.util.Utils;

import java.io.Externalizable;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInput;
import java.io.ObjectInputStream;
import java.io.ObjectOutput;
import java.io.ObjectOutputStream;
import java.io.OutputStream;
import java.io.Serializable;
import java.io.StringWriter;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

/**
 * Augments Java access control by verifying that a project and its dependencies
 * don't statically violate a policy.
 */
<span class="nc" id="L83">public final class FencesMavenEnforcerRule implements EnforcerRule {</span>

<span class="nc" id="L85">  private final List&lt;Fence&gt; fences = Lists.newArrayList();</span>
<span class="nc" id="L86">  private final LinkedList&lt;ConfigurationImport&gt; imports = Lists.newLinkedList();</span>
<span class="nc" id="L87">  private final Set&lt;ConfigurationImport.PartialArtifactKey&gt; alreadyImported =</span>
<span class="nc" id="L88">      Sets.newLinkedHashSet();</span>

  private void addFence(Fence f) throws MisconfigurationException {
<span class="nc" id="L91">    f.check();</span>
<span class="nc" id="L92">    fences.add(f);</span>
<span class="nc" id="L93">  }</span>

  /**
   * A setter called by reflection during configuration.  Actually adds
   * instead of blowing away prior value.
   */
  public void setApi(ApiFence x) throws MisconfigurationException {
<span class="nc" id="L100">    addFence(x);</span>
<span class="nc" id="L101">  }</span>

  /**
   * A setter called by reflection during configuration.  Actually adds
   * instead of blowing away prior value.
   */
  public void setPackage(PackageFence x) throws MisconfigurationException {
<span class="nc" id="L108">    addFence(x);</span>
<span class="nc" id="L109">  }</span>

  /**
   * A setter called by reflection during configuration.  Actually adds
   * instead of blowing away prior value.
   */
  public void setClass(ClassFence x) throws MisconfigurationException {
<span class="nc" id="L116">    addFence(x);</span>
<span class="nc" id="L117">  }</span>

  /**
   * A setter called by reflection during configuration.  Actually adds
   * instead of blowing away prior value.
   */
  public void setImport(String x) throws MisconfigurationException {
<span class="nc" id="L124">    imports.add(new ConfigurationImport(x));</span>
<span class="nc" id="L125">  }</span>

  /**
   * A setter called by reflection during configuration.  Actually adds
   * an {@code &lt;api&gt;} with an {@code &lt;addendum&gt;} instead of blowing away prior
   * value.
   */
  public void setAddendum(String x) throws MisconfigurationException {
<span class="nc" id="L133">    Fence api = new ApiFence();</span>
<span class="nc" id="L134">    api.setAddendum(x);</span>
<span class="nc" id="L135">    fences.add(api);</span>
<span class="nc" id="L136">  }</span>

  @Override
  public void execute(EnforcerRuleHelper helper) throws EnforcerRuleException {
<span class="nc" id="L140">    final Log log = helper.getLog();</span>

    // TODO: maybe check MavenSession.getGoals() to see if this is being
    // run at phase &quot;validate&quot; instead of phase &quot;verify&quot; to warn of a
    // missing &lt;phase&gt;verify&lt;/phase&gt; in the enforcer plugin configuration.

    ArtifactResolver resolver;
    DependencyTreeBuilder treeBuilder;
    ComponentConfigurator configurator;
    try {
<span class="nc" id="L150">      resolver = (ArtifactResolver) helper.getComponent(ArtifactResolver.class);</span>
<span class="nc" id="L151">      treeBuilder = (DependencyTreeBuilder)</span>
<span class="nc" id="L152">          helper.getComponent(DependencyTreeBuilder.class);</span>

      // This seems &quot;the right way&quot; since plexus is supposed to inject
      // dependencies, but when run without -X to turn on debugging,
      // we get a MapOrientedComponentConfigurator which cannot configure
      // this object.
      // http://stackoverflow.com/questions/35919157/using-xmlplexusconfiguration-to-import-more-configuration-for-a-bean-style-maven
      // explains the symptoms.
      //  configurator = (ComponentConfigurator) helper.getComponent(
      //      ComponentConfigurator.class);
<span class="nc" id="L162">      configurator = new BasicComponentConfigurator();</span>
<span class="nc" id="L163">    } catch (ComponentLookupException ex) {</span>
<span class="nc" id="L164">      throw new EnforcerRuleException(</span>
<span class="nc" id="L165">          &quot;Failed to locate component: &quot; + ex.getLocalizedMessage(), ex);</span>
<span class="nc" id="L166">    }</span>

    MavenProject project;
    ArtifactRepository localRepository;
    List&lt;ArtifactRepository&gt; remoteRepositories;
    File buildDirectory;
    try {
<span class="nc" id="L173">      project = (MavenProject) helper.evaluate(&quot;${project}&quot;);</span>
<span class="nc" id="L174">      localRepository = (ArtifactRepository)</span>
<span class="nc" id="L175">          helper.evaluate(&quot;${localRepository}&quot;);</span>
      @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L177">      List&lt;ArtifactRepository&gt; rr = (List&lt;ArtifactRepository&gt;)</span>
<span class="nc" id="L178">          helper.evaluate(&quot;${project.remoteArtifactRepositories}&quot;);</span>
<span class="nc" id="L179">      remoteRepositories = rr;</span>
<span class="nc" id="L180">      buildDirectory = new File(</span>
<span class="nc" id="L181">          (String) helper.evaluate(&quot;${project.build.directory}&quot;));</span>
<span class="nc" id="L182">    } catch (ExpressionEvaluationException ex) {</span>
<span class="nc" id="L183">      throw new EnforcerRuleException(</span>
<span class="nc" id="L184">          &quot;Failed to locate component: &quot; + ex.getLocalizedMessage(), ex);</span>
<span class="nc" id="L185">    }</span>

<span class="nc" id="L187">    ArtifactFinder finder = new ArtifactFinder(</span>
        resolver, treeBuilder, localRepository, remoteRepositories, log);

    try {
<span class="nc" id="L191">      finder.findClassRoots(project);</span>
<span class="nc" id="L192">    } catch (DependencyTreeBuilderException ex) {</span>
<span class="nc" id="L193">      throw new EnforcerRuleException(&quot;Failed to find artifacts&quot;, ex);</span>
<span class="nc" id="L194">    } catch (ArtifactResolutionException ex) {</span>
<span class="nc" id="L195">      throw new EnforcerRuleException(&quot;Failed to find artifacts&quot;, ex);</span>
<span class="nc" id="L196">    } catch (ArtifactNotFoundException ex) {</span>
<span class="nc" id="L197">      throw new EnforcerRuleException(&quot;Failed to find artifacts&quot;, ex);</span>
<span class="nc" id="L198">    } catch (MisconfigurationException ex) {</span>
<span class="nc" id="L199">      throw new EnforcerRuleException(&quot;Failed to find artifacts&quot;, ex);</span>
<span class="nc" id="L200">    }</span>

<span class="nc" id="L202">    ImmutableList&lt;ClassRoot&gt; classRoots = finder.getClassRoots();</span>

    InheritanceGraph inheritanceGraph;
    try {
<span class="nc" id="L206">      inheritanceGraph = InheritanceGraphExtractor</span>
<span class="nc" id="L207">          .fromClassRoots(classRoots);</span>
<span class="nc" id="L208">    } catch (IOException ex) {</span>
<span class="nc" id="L209">      throw new EnforcerRuleException(</span>
          &quot;Failed to read classes to find inheritance relationships&quot;,
          ex);
<span class="nc" id="L212">    }</span>

    try {
<span class="nc" id="L215">      int nAssignedImportOrder = 0;</span>
<span class="nc" id="L216">      int importOrder = 0;</span>
      // Do the imports.
      // Since an import might load a configuration that adds more imports, we
      // just walk the list destructively.
<span class="nc bnc" id="L220" title="All 2 branches missed.">      for (; !imports.isEmpty(); ++importOrder) {</span>
<span class="nc" id="L221">        nAssignedImportOrder = rerootAndAssignImportOrder(</span>
            inheritanceGraph, nAssignedImportOrder, importOrder);
<span class="nc" id="L223">        ConfigurationImport imp = imports.removeFirst();</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">        if (alreadyImported.add(imp.key)) {</span>
<span class="nc" id="L225">          log.debug(&quot;Importing &quot; + imp.key);</span>
          try {
<span class="nc" id="L227">            imp.configure(</span>
                this, configurator,
<span class="nc" id="L229">                new ConfigurationImport.ClassRoots(classRoots.iterator()),</span>
                log);
<span class="nc" id="L231">          } catch (MisconfigurationException ex) {</span>
<span class="nc" id="L232">            throw new EnforcerRuleException(&quot;Failed to import &quot; + imp.key, ex);</span>
<span class="nc" id="L233">          }</span>
        } else {
<span class="nc" id="L235">          log.info(&quot;Not importing &quot; + imp.key + &quot; a second time&quot;);</span>
        }
      }
<span class="nc" id="L238">      rerootAndAssignImportOrder(</span>
          inheritanceGraph, nAssignedImportOrder, importOrder);
<span class="nc" id="L240">    } catch (MisconfigurationException ex) {</span>
<span class="nc" id="L241">      throw new EnforcerRuleException(ex.getMessage(), ex);</span>
<span class="nc" id="L242">    }</span>

<span class="nc" id="L244">    ImmutableList&lt;Fence&gt; allFences = ImmutableList.copyOf(fences);</span>

<span class="nc bnc" id="L246" title="All 2 branches missed.">    if (allFences.isEmpty()) {</span>
<span class="nc" id="L247">      throw new EnforcerRuleException(</span>
          &quot;No fences.  Please configure this rule with a policy.&quot;
          + &quot;  See https://github.com/mikesamuel/&quot;
          + &quot;fences-maven-enforcer-rule/blob/master/src/site/markdown/usage.md&quot;
          + &quot; for details&quot;);
    }

    // Merge all the fences into one master.
<span class="nc" id="L255">    final ApiFence mergedFence = new ApiFence();</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">    for (Fence f : allFences) {</span>
<span class="nc" id="L257">      mergedFence.mergeDeep(f);</span>
<span class="nc" id="L258">    }</span>

    // Log the effective configuration
<span class="nc" id="L261">    boolean showConfig = RelevantSystemProperties.shouldShowEffectiveConfig();</span>
<span class="nc bnc" id="L262" title="All 4 branches missed.">    if (showConfig || log.isDebugEnabled()) {</span>
      try {
<span class="nc" id="L264">        Element config = mergedFence.buildEffectiveConfiguration();</span>
<span class="nc" id="L265">        TransformerFactory tf = TransformerFactory.newInstance();</span>
<span class="nc" id="L266">        Transformer transformer = tf.newTransformer();</span>
<span class="nc" id="L267">        transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, &quot;yes&quot;);</span>
<span class="nc" id="L268">        transformer.setOutputProperty(OutputKeys.METHOD, &quot;xml&quot;);</span>
<span class="nc" id="L269">        transformer.setOutputProperty(OutputKeys.INDENT, &quot;yes&quot;);</span>
<span class="nc" id="L270">        transformer.setOutputProperty(OutputKeys.ENCODING, &quot;UTF-8&quot;);</span>
<span class="nc" id="L271">        transformer.setOutputProperty(</span>
            &quot;{http://xml.apache.org/xslt}indent-amount&quot;, &quot;2&quot;);

<span class="nc" id="L274">        StringWriter xmlOut = new StringWriter();</span>
<span class="nc" id="L275">        xmlOut.write(&quot;Effective Fences Rule Configuration:\n&quot;);</span>
<span class="nc" id="L276">        transformer.transform(</span>
            new DOMSource(config),
            new StreamResult(xmlOut));
<span class="nc" id="L279">        String xml = xmlOut.toString();</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">        if (showConfig) {</span>
<span class="nc" id="L281">          log.info(xml);</span>
        } else {
<span class="nc" id="L283">          log.debug(xml);</span>
        }
<span class="nc" id="L285">      } catch (ParserConfigurationException ex) {</span>
<span class="nc" id="L286">        log.error(ex);</span>
<span class="nc" id="L287">      } catch (TransformerException ex) {</span>
<span class="nc" id="L288">        log.error(ex);</span>
<span class="nc" id="L289">      }</span>
    }

<span class="nc" id="L292">    File artifactFindingsFile = new File(buildDirectory, &quot;.fences-cache.ser&quot;);</span>
    // TODO: store in the file, a hash of the effective policy so we can do
    // a master check that the policy hasn't changed.
<span class="nc" id="L295">    ArtifactFindingsHash afHash = ArtifactFindingsHash.readFrom(</span>
<span class="nc" id="L296">        Files.asByteSource(artifactFindingsFile));</span>

<span class="nc" id="L298">    checkAllClasses(</span>
        project, log, inheritanceGraph, mergedFence, classRoots, afHash);

<span class="nc" id="L301">    ignore(artifactFindingsFile.getParentFile().mkdirs());</span>
<span class="nc" id="L302">    afHash.writeTo(Files.asByteSink(artifactFindingsFile));</span>
<span class="nc" id="L303">  }</span>

  private int rerootAndAssignImportOrder(
      InheritanceGraph inheritanceGraph, int start, int importOrder)
  throws MisconfigurationException {
<span class="nc" id="L308">    int end = fences.size();</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">    for (int i = start; i &lt; end; ++i) {</span>
<span class="nc" id="L310">      Fence f = fences.get(i);</span>
<span class="nc" id="L311">      f = f.splitDottedNames(ApiElement.DEFAULT_PACKAGE, inheritanceGraph)</span>
<span class="nc" id="L312">          .promoteToApi();</span>
<span class="nc" id="L313">      f.assignImportOrder(importOrder);</span>
<span class="nc" id="L314">      fences.set(i, f);</span>
    }
<span class="nc" id="L316">    return end;</span>
  }

  protected static void checkAllClasses(
      MavenProject project, Log backingLog, InheritanceGraph inheritanceGraph,
      ApiFence mergedFence, Iterable&lt;? extends ClassRoot&gt; classRoots,
      ArtifactFindingsHash afHash)
  throws EnforcerRuleException {
<span class="nc" id="L324">    final Policy p = Policy.fromFence(mergedFence);</span>

<span class="nc" id="L326">    RecordingLog log = new RecordingLog(backingLog);</span>

<span class="nc" id="L328">    log.debug(new LazyString() {</span>
      @Override
      protected String makeString() {
<span class="nc" id="L331">        return &quot;Using policy\n&quot; + p.toString();</span>
      }
    });

<span class="nc" id="L335">    Checker checker = new Checker(log, inheritanceGraph, p);</span>

<span class="nc bnc" id="L337" title="All 2 branches missed.">    for (ClassRoot classRoot : classRoots) {</span>
<span class="nc" id="L338">      HashCode hashcode = null;</span>

<span class="nc" id="L340">      Artifact art = classRoot.art;</span>

      // If we have cached findings for this artifact, replay them instead
      // of scanning the whole thing again.
<span class="nc" id="L344">      String artId = art.getId();</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">      switch (classRoot.kind) {</span>
        case ZIPFILE:
<span class="nc bnc" id="L347" title="All 2 branches missed.">          if (classRoot.classRoot.exists()) {</span>
            try {
<span class="nc" id="L349">              hashcode = ArtifactFindingsHash.HASH_FUNCTION.hashBytes(</span>
<span class="nc" id="L350">                  Files.toByteArray(classRoot.classRoot));</span>
<span class="nc" id="L351">            } catch (IOException ex) {</span>
<span class="nc" id="L352">              log.warn(&quot;Trouble hashing zipfile&quot;, ex);</span>
<span class="nc" id="L353">            }</span>
          }
          break;
        default:
          break;
      }

<span class="nc bnc" id="L360" title="All 2 branches missed.">      if (hashcode != null) {</span>
<span class="nc" id="L361">        Optional&lt;ImmutableList&lt;RecordingLog.Entry&gt;&gt; hashedResults =</span>
<span class="nc" id="L362">            afHash.get(artId, hashcode);</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">        if (hashedResults.isPresent()) {</span>
<span class="nc" id="L364">          backingLog.debug(&quot;Replaying cached results for &quot; + artId);</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">          for (RecordingLog.Entry e : hashedResults.get()) {</span>
<span class="nc" id="L366">            e.apply(backingLog);</span>
<span class="nc" id="L367">          }</span>
<span class="nc" id="L368">          continue;</span>
        }
      }

<span class="nc" id="L372">      log.info(&quot;Checking &quot; + artId + &quot; from scope &quot; + art.getScope());</span>
<span class="nc" id="L373">      log.reset();</span>
      try {
<span class="nc" id="L375">        checker.visitAll(ImmutableList.of(classRoot));</span>
<span class="nc" id="L376">      } catch (IOException ex) {</span>
<span class="nc" id="L377">        throw new EnforcerRuleException(</span>
<span class="nc" id="L378">            &quot;Failed to check &quot; + Utils.artToString(art), ex);</span>
<span class="nc" id="L379">      }</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">      if (hashcode != null) {</span>
<span class="nc" id="L381">        afHash.store(artId, hashcode, log.getEntriesSinceLastReset());</span>
      }
<span class="nc" id="L383">    }</span>

<span class="nc" id="L385">    ImmutableList&lt;Violation&gt; violations = checker.getViolations();</span>
<span class="nc" id="L386">    PolicyViolationReporter reporter = new PolicyViolationReporter(log);</span>
<span class="nc" id="L387">    reporter.interpolator.addValueSource(</span>
<span class="nc" id="L388">        new PropertiesBasedValueSource(project.getProperties()));</span>
<span class="nc" id="L389">    int errorCount = reporter.report(violations);</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">    if (errorCount != 0) {</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">      String message = errorCount + &quot; access policy violation&quot;</span>
          + (errorCount == 1 ? &quot;&quot; : &quot;s&quot;);
<span class="nc bnc" id="L393" title="All 2 branches missed.">      if (RelevantSystemProperties.inExperimentalMode()) {</span>
<span class="nc" id="L394">        log.info(message + &quot; ignored in experimental mode&quot;);</span>
      } else {
<span class="nc" id="L396">        throw new EnforcerRuleException(message);</span>
      }
    }
<span class="nc" id="L399">  }</span>

  @Override
  public String getCacheId() {
<span class="nc" id="L403">    return null;</span>
  }

  @Override
  public boolean isCacheable() {
<span class="nc" id="L408">    return false;</span>
  }

  @Override
  public boolean isResultValid(EnforcerRule arg0) {
<span class="nc" id="L413">    return false;</span>
  }



<span class="nc" id="L418">  static final class ArtifactFindingsHash implements Serializable {</span>

    private static final long serialVersionUID = 3323962310197443927L;

<span class="nc" id="L422">    static final HashFunction HASH_FUNCTION = Hashing.sha512();</span>

<span class="nc" id="L424">    private final Map&lt;String, HashedResult&gt; hashedResults =</span>
<span class="nc" id="L425">        Maps.newLinkedHashMap();</span>

    Optional&lt;ImmutableList&lt;RecordingLog.Entry&gt;&gt; get(
        String artId, HashCode hashcode) {
<span class="nc" id="L429">      HashedResult r = hashedResults.get(artId);</span>
<span class="nc bnc" id="L430" title="All 4 branches missed.">      if (r != null &amp;&amp; r.getHashcode().equals(hashcode)) {</span>
<span class="nc" id="L431">        return Optional.of(r.getEntries());</span>
      }
<span class="nc" id="L433">      return Optional.absent();</span>
    }

    void store(String artId, HashCode hashcode,
               Iterable&lt;? extends RecordingLog.Entry&gt; entries) {
<span class="nc" id="L438">      hashedResults.put(</span>
          artId,
<span class="nc" id="L440">          new HashedResult(hashcode, ImmutableList.copyOf(entries)));</span>
<span class="nc" id="L441">    }</span>

    static ArtifactFindingsHash readFrom(ByteSource byteSource)
    throws EnforcerRuleException {
      Object read;
      try {
<span class="nc" id="L447">        InputStream in = byteSource.openStream();</span>
        try {
<span class="nc" id="L449">          ObjectInputStream objIn = new ObjectInputStream(in);</span>
          try {
<span class="nc" id="L451">            read = objIn.readObject();</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">            if (in.read() &gt;= 0) {</span>
<span class="nc" id="L453">              throw new IOException(&quot;Extraneous content in &quot; + byteSource);</span>
            }
          } finally {
<span class="nc" id="L456">            objIn.close();</span>
<span class="nc" id="L457">          }</span>
        } finally {
<span class="nc" id="L459">          in.close();</span>
<span class="nc" id="L460">        }</span>
<span class="nc" id="L461">      } catch (ClassNotFoundException ex) {</span>
<span class="nc" id="L462">        throw new EnforcerRuleException(</span>
            &quot;Failed to read artifact findings cache&quot;, ex);
<span class="nc" id="L464">      } catch (@SuppressWarnings(&quot;unused&quot;) FileNotFoundException ex) {</span>
        // If there's no hash, just create a blank one.
<span class="nc" id="L466">        read = new ArtifactFindingsHash();</span>
<span class="nc" id="L467">      } catch (IOException ex) {</span>
<span class="nc" id="L468">        throw new EnforcerRuleException(</span>
            &quot;Failed to read artifact findings cache&quot;, ex);
<span class="nc" id="L470">      }</span>
<span class="nc" id="L471">      return Preconditions.checkNotNull((ArtifactFindingsHash) read);</span>
    }

    void writeTo(ByteSink byteSink) throws EnforcerRuleException {
      try {
<span class="nc" id="L476">        OutputStream out = byteSink.openStream();</span>
        try {
<span class="nc" id="L478">          ObjectOutputStream objOut = new ObjectOutputStream(out);</span>
          try {
<span class="nc" id="L480">            objOut.writeObject(this);</span>
          } finally {
<span class="nc" id="L482">            objOut.close();</span>
<span class="nc" id="L483">          }</span>
        } finally {
<span class="nc" id="L485">          out.close();</span>
<span class="nc" id="L486">        }</span>
<span class="nc" id="L487">      } catch (IOException ex) {</span>
<span class="nc" id="L488">        throw new EnforcerRuleException(</span>
            &quot;Failed to write artifact findings cache&quot;, ex);
<span class="nc" id="L490">      }</span>
<span class="nc" id="L491">    }</span>
  }

  static final class HashedResult implements Externalizable {
    private HashCode hashcode;
    private ImmutableList&lt;RecordingLog.Entry&gt; entries;

<span class="nc" id="L498">    public HashedResult() {</span>
      // for externalizable
<span class="nc" id="L500">    }</span>

    public ImmutableList&lt;Entry&gt; getEntries() {
<span class="nc" id="L503">      return entries;</span>
    }

    public HashCode getHashcode() {
<span class="nc" id="L507">      return hashcode;</span>
    }

<span class="nc" id="L510">    HashedResult(HashCode hashcode, ImmutableList&lt;RecordingLog.Entry&gt; entries) {</span>
<span class="nc" id="L511">      this.hashcode = hashcode;</span>
<span class="nc" id="L512">      this.entries = entries;</span>
<span class="nc" id="L513">    }</span>

    @Override
    public void writeExternal(ObjectOutput out) throws IOException {
<span class="nc" id="L517">      out.writeObject(hashcode.asBytes());</span>
<span class="nc" id="L518">      out.writeObject(entries);</span>
<span class="nc" id="L519">    }</span>

    @Override
    public void readExternal(ObjectInput in)
    throws IOException, ClassNotFoundException {
<span class="nc" id="L524">      hashcode = HashCode.fromBytes((byte[]) in.readObject());</span>
<span class="nc" id="L525">      ImmutableList.Builder&lt;RecordingLog.Entry&gt; b = ImmutableList.builder();</span>
<span class="nc bnc" id="L526" title="All 2 branches missed.">      for (Object entry : (Iterable&lt;?&gt;)  in.readObject()) {</span>
<span class="nc" id="L527">        b.add((RecordingLog.Entry) entry);</span>
<span class="nc" id="L528">      }</span>
<span class="nc" id="L529">      entries = b.build();</span>
<span class="nc" id="L530">    }</span>
  }

  private static void ignore(@SuppressWarnings(&quot;unused&quot;) boolean b) {
    // Deal with findbugs complaint.
<span class="nc" id="L535">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>