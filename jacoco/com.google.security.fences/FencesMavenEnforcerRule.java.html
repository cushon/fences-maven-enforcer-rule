<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>FencesMavenEnforcerRule.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Fences Enforcer Rule</a> &gt; <a href="index.source.html" class="el_package">com.google.security.fences</a> &gt; <span class="el_source">FencesMavenEnforcerRule.java</span></div><h1>FencesMavenEnforcerRule.java</h1><pre class="source lang-java linenums">package com.google.security.fences;

import org.apache.maven.artifact.Artifact;
import org.apache.maven.artifact.repository.ArtifactRepository;
import org.apache.maven.artifact.resolver.ArtifactNotFoundException;
import org.apache.maven.artifact.resolver.ArtifactResolutionException;
import org.apache.maven.artifact.resolver.ArtifactResolver;
import org.apache.maven.enforcer.rule.api.EnforcerRule;
import org.apache.maven.enforcer.rule.api.EnforcerRuleException;
import org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;
import org.apache.maven.plugin.logging.Log;
import org.apache.maven.project.MavenProject;
import org.apache.maven.shared.dependency.tree.DependencyTreeBuilder;
import org.apache.maven.shared.dependency.tree.DependencyTreeBuilderException;
import org.codehaus.plexus.component.configurator.BasicComponentConfigurator;
import org.codehaus.plexus.component.configurator.ComponentConfigurator;
import org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;
import org.codehaus.plexus.component.repository.exception.ComponentLookupException;
import org.codehaus.plexus.interpolation.PropertiesBasedValueSource;
import org.w3c.dom.Element;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;
import com.google.security.fences.config.ApiFence;
import com.google.security.fences.config.ClassFence;
import com.google.security.fences.config.Fence;
import com.google.security.fences.config.PackageFence;
import com.google.security.fences.inheritance.InheritanceGraph;
import com.google.security.fences.policy.Policy;
import com.google.security.fences.util.LazyString;
import com.google.security.fences.util.Utils;

import java.io.IOException;
import java.io.StringWriter;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

/**
 * Augments Java access control by verifying that a project and its dependencies
 * don't statically violate a policy.
 */
<span class="nc" id="L52">public final class FencesMavenEnforcerRule implements EnforcerRule {</span>

<span class="nc" id="L54">  private final List&lt;Fence&gt; fences = Lists.newArrayList();</span>
<span class="nc" id="L55">  private final LinkedList&lt;ConfigurationImport&gt; imports = Lists.newLinkedList();</span>
<span class="nc" id="L56">  private final Set&lt;ConfigurationImport.PartialArtifactKey&gt; alreadyImported =</span>
<span class="nc" id="L57">      Sets.newLinkedHashSet();</span>

  private void addFence(Fence f) throws EnforcerRuleException {
<span class="nc" id="L60">    f.check();</span>
<span class="nc" id="L61">    fences.add(f.splitDottedNames());</span>
<span class="nc" id="L62">  }</span>

  /**
   * A setter called by reflection during configuration.  Actually adds
   * instead of blowing away prior value.
   */
  public void setApi(ApiFence x) throws EnforcerRuleException {
<span class="nc" id="L69">    addFence(x);</span>
<span class="nc" id="L70">  }</span>

  /**
   * A setter called by reflection during configuration.  Actually adds
   * instead of blowing away prior value.
   */
  public void setPackage(PackageFence x) throws EnforcerRuleException {
<span class="nc" id="L77">    addFence(x);</span>
<span class="nc" id="L78">  }</span>

  /**
   * A setter called by reflection during configuration.  Actually adds
   * instead of blowing away prior value.
   */
  public void setClass(ClassFence x) throws EnforcerRuleException {
<span class="nc" id="L85">    addFence(x);</span>
<span class="nc" id="L86">  }</span>

  /**
   * A setter called by reflection during configuration.  Actually adds
   * instead of blowing away prior value.
   */
  public void setImport(String x) throws EnforcerRuleException {
<span class="nc" id="L93">    imports.add(new ConfigurationImport(x));</span>
<span class="nc" id="L94">  }</span>

  /**
   * A setter called by reflection during configuration.  Actually adds
   * an {@code &lt;api&gt;} with an {@code &lt;addendum&gt;} instead of blowing away prior
   * value.
   */
  public void setAddendum(String x) throws EnforcerRuleException {
<span class="nc" id="L102">    Fence api = new ApiFence();</span>
<span class="nc" id="L103">    api.setAddendum(x);</span>
<span class="nc" id="L104">    fences.add(api);</span>
<span class="nc" id="L105">  }</span>

  public void execute(EnforcerRuleHelper helper) throws EnforcerRuleException {
<span class="nc" id="L108">    final Log log = helper.getLog();</span>

    // TODO: maybe check MavenSession.getGoals() to see if this is being
    // run at phase &quot;validate&quot; instead of phase &quot;verify&quot; to warn of a
    // missing &lt;phase&gt;verify&lt;/phase&gt; in the enforcer plugin configuration.

    ArtifactResolver resolver;
    DependencyTreeBuilder treeBuilder;
    ComponentConfigurator configurator;
    try {
<span class="nc" id="L118">      resolver = (ArtifactResolver) helper.getComponent(ArtifactResolver.class);</span>
<span class="nc" id="L119">      treeBuilder = (DependencyTreeBuilder)</span>
<span class="nc" id="L120">          helper.getComponent(DependencyTreeBuilder.class);</span>

      // This seems &quot;the right way&quot; since plexus is supposed to inject
      // dependencies, but when run without -X to turn on debugging,
      // we get a MapOrientedComponentConfigurator which cannot configure
      // this object.
      // http://stackoverflow.com/questions/35919157/using-xmlplexusconfiguration-to-import-more-configuration-for-a-bean-style-maven
      // explains the symptoms.
      //  configurator = (ComponentConfigurator) helper.getComponent(
      //      ComponentConfigurator.class);
<span class="nc" id="L130">      configurator = new BasicComponentConfigurator();</span>
<span class="nc" id="L131">    } catch (ComponentLookupException ex) {</span>
<span class="nc" id="L132">      throw new EnforcerRuleException(</span>
<span class="nc" id="L133">          &quot;Failed to locate component: &quot; + ex.getLocalizedMessage(), ex);</span>
<span class="nc" id="L134">    }</span>

    MavenProject project;
    ArtifactRepository localRepository;
    List&lt;ArtifactRepository&gt; remoteRepositories;
    try {
<span class="nc" id="L140">      project = (MavenProject) helper.evaluate(&quot;${project}&quot;);</span>
<span class="nc" id="L141">      localRepository = (ArtifactRepository)</span>
<span class="nc" id="L142">          helper.evaluate(&quot;${localRepository}&quot;);</span>
      @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L144">      List&lt;ArtifactRepository&gt; rr = (List&lt;ArtifactRepository&gt;)</span>
<span class="nc" id="L145">          helper.evaluate(&quot;${project.remoteArtifactRepositories}&quot;);</span>
<span class="nc" id="L146">      remoteRepositories = rr;</span>
<span class="nc" id="L147">    } catch (ExpressionEvaluationException ex) {</span>
<span class="nc" id="L148">      throw new EnforcerRuleException(</span>
<span class="nc" id="L149">          &quot;Failed to locate component: &quot; + ex.getLocalizedMessage(), ex);</span>
<span class="nc" id="L150">    }</span>

<span class="nc" id="L152">    ArtifactFinder finder = new ArtifactFinder(</span>
        resolver, treeBuilder, localRepository, remoteRepositories, log);

    try {
<span class="nc" id="L156">      finder.findClassRoots(project);</span>
<span class="nc" id="L157">    } catch (DependencyTreeBuilderException ex) {</span>
<span class="nc" id="L158">      throw new EnforcerRuleException(&quot;Failed to find artifacts&quot;, ex);</span>
<span class="nc" id="L159">    } catch (ArtifactResolutionException ex) {</span>
<span class="nc" id="L160">      throw new EnforcerRuleException(&quot;Failed to find artifacts&quot;, ex);</span>
<span class="nc" id="L161">    } catch (ArtifactNotFoundException ex) {</span>
<span class="nc" id="L162">      throw new EnforcerRuleException(&quot;Failed to find artifacts&quot;, ex);</span>
<span class="nc" id="L163">    }</span>

<span class="nc" id="L165">    ImmutableList&lt;ClassRoot&gt; classRoots = finder.getClassRoots();</span>

<span class="nc" id="L167">    int nAssignedImportOrder = 0;</span>
<span class="nc" id="L168">    int importOrder = 0;</span>
    // Do the imports.
    // Since an import might load a configuration that adds more imports, we
    // just walk the list destructively.
<span class="nc bnc" id="L172" title="All 2 branches missed.">    for (; !imports.isEmpty(); ++importOrder) {</span>
<span class="nc" id="L173">      nAssignedImportOrder = rerootAndAssignImportOrder(</span>
          nAssignedImportOrder, importOrder);
<span class="nc" id="L175">      ConfigurationImport imp = imports.removeFirst();</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">      if (alreadyImported.add(imp.key)) {</span>
<span class="nc" id="L177">        log.debug(&quot;Importing &quot; + imp.key);</span>
<span class="nc" id="L178">        imp.configure(</span>
            this, configurator,
<span class="nc" id="L180">            new ConfigurationImport.ClassRoots(classRoots.iterator()),</span>
            log);
      } else {
<span class="nc" id="L183">        log.info(&quot;Not importing &quot; + imp.key + &quot; a second time&quot;);</span>
      }
    }
<span class="nc" id="L186">    rerootAndAssignImportOrder(nAssignedImportOrder, importOrder);</span>

<span class="nc" id="L188">    ImmutableList&lt;Fence&gt; allFences = ImmutableList.copyOf(fences);</span>

<span class="nc bnc" id="L190" title="All 2 branches missed.">    if (allFences.isEmpty()) {</span>
<span class="nc" id="L191">      throw new EnforcerRuleException(</span>
          &quot;No fences.  Please configure this rule with a policy.&quot;
          + &quot;  See https://github.com/mikesamuel/&quot;
          + &quot;fences-maven-enforcer-rule/blob/master/src/site/markdown/usage.md&quot;
          + &quot; for details&quot;);
    }

    // Merge all the fences into one master.
<span class="nc" id="L199">    final ApiFence mergedFence = new ApiFence();</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">    for (Fence f : allFences) {</span>
<span class="nc" id="L201">      mergedFence.mergeDeep(f);</span>
<span class="nc" id="L202">    }</span>

    // Log the effective configuration
<span class="nc" id="L205">    boolean showConfig = RelevantSystemProperties.shouldShowEffectiveConfig();</span>
<span class="nc bnc" id="L206" title="All 4 branches missed.">    if (showConfig || log.isDebugEnabled()) {</span>
      try {
<span class="nc" id="L208">        Element config = mergedFence.buildEffectiveConfiguration();</span>
<span class="nc" id="L209">        TransformerFactory tf = TransformerFactory.newInstance();</span>
<span class="nc" id="L210">        Transformer transformer = tf.newTransformer();</span>
<span class="nc" id="L211">        transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, &quot;yes&quot;);</span>
<span class="nc" id="L212">        transformer.setOutputProperty(OutputKeys.METHOD, &quot;xml&quot;);</span>
<span class="nc" id="L213">        transformer.setOutputProperty(OutputKeys.INDENT, &quot;yes&quot;);</span>
<span class="nc" id="L214">        transformer.setOutputProperty(OutputKeys.ENCODING, &quot;UTF-8&quot;);</span>
<span class="nc" id="L215">        transformer.setOutputProperty(</span>
            &quot;{http://xml.apache.org/xslt}indent-amount&quot;, &quot;2&quot;);

<span class="nc" id="L218">        StringWriter xmlOut = new StringWriter();</span>
<span class="nc" id="L219">        xmlOut.write(&quot;Effective Fences Rule Configuration:\n&quot;);</span>
<span class="nc" id="L220">        transformer.transform(</span>
            new DOMSource(config),
            new StreamResult(xmlOut));
<span class="nc" id="L223">        String xml = xmlOut.toString();</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">        if (showConfig) {</span>
<span class="nc" id="L225">          log.info(xml);</span>
        } else {
<span class="nc" id="L227">          log.debug(xml);</span>
        }
<span class="nc" id="L229">      } catch (ParserConfigurationException ex) {</span>
<span class="nc" id="L230">        log.error(ex);</span>
<span class="nc" id="L231">      } catch (TransformerException ex) {</span>
<span class="nc" id="L232">        log.error(ex);</span>
<span class="nc" id="L233">      }</span>
    }

<span class="nc" id="L236">    checkAllClasses(project, mergedFence, log, classRoots);</span>
<span class="nc" id="L237">  }</span>

  private int rerootAndAssignImportOrder(int start, int importOrder) {
<span class="nc" id="L240">    int end = fences.size();</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">    for (int i = start; i &lt; end; ++i) {</span>
<span class="nc" id="L242">      Fence f = fences.get(i);</span>
<span class="nc" id="L243">      f = f.splitDottedNames().promoteToApi();</span>
<span class="nc" id="L244">      f.assignImportOrder(importOrder);</span>
<span class="nc" id="L245">      fences.set(i, f);</span>
    }
<span class="nc" id="L247">    return end;</span>
  }

  protected static void checkAllClasses(
      MavenProject project, ApiFence mergedFence,
      Log log, Iterable&lt;? extends ClassRoot&gt; classRoots)
  throws EnforcerRuleException {
    InheritanceGraph inheritanceGraph;
    try {
<span class="nc" id="L256">      inheritanceGraph = InheritanceGraphExtractor</span>
<span class="nc" id="L257">          .fromClassRoots(classRoots);</span>
<span class="nc" id="L258">    } catch (IOException ex) {</span>
<span class="nc" id="L259">      throw new EnforcerRuleException(</span>
          &quot;Failed to read classes to find inheritance relationships&quot;,
          ex);
<span class="nc" id="L262">    }</span>

<span class="nc" id="L264">    final Policy p = Policy.fromFence(mergedFence);</span>
<span class="nc" id="L265">    log.debug(new LazyString() {</span>
      @Override
      protected String makeString() {
<span class="nc" id="L268">        return &quot;Using policy\n&quot; + p.toString();</span>
      }
    });

<span class="nc" id="L272">    Checker checker = new Checker(log, inheritanceGraph, p);</span>

<span class="nc bnc" id="L274" title="All 2 branches missed.">    for (ClassRoot classRoot : classRoots) {</span>
<span class="nc" id="L275">      Artifact art = classRoot.art;</span>
<span class="nc" id="L276">      log.info(&quot;Checking &quot; + art.getId() + &quot; from scope &quot; + art.getScope());</span>
      try {
<span class="nc" id="L278">        checker.visitAll(ImmutableList.of(classRoot));</span>
<span class="nc" id="L279">      } catch (IOException ex) {</span>
<span class="nc" id="L280">        throw new EnforcerRuleException(</span>
<span class="nc" id="L281">            &quot;Failed to check &quot; + Utils.artToString(art), ex);</span>
<span class="nc" id="L282">      }</span>
<span class="nc" id="L283">    }</span>

<span class="nc" id="L285">    ImmutableList&lt;Violation&gt; violations = checker.getViolations();</span>
<span class="nc" id="L286">    PolicyViolationReporter reporter = new PolicyViolationReporter(log);</span>
<span class="nc" id="L287">    reporter.interpolator.addValueSource(</span>
<span class="nc" id="L288">        new PropertiesBasedValueSource(project.getProperties()));</span>
<span class="nc" id="L289">    int errorCount = reporter.report(violations);</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">    if (errorCount != 0) {</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">      String message = errorCount + &quot; access policy violation&quot;</span>
          + (errorCount == 1 ? &quot;&quot; : &quot;s&quot;);
<span class="nc bnc" id="L293" title="All 2 branches missed.">      if (RelevantSystemProperties.inExperimentalMode()) {</span>
<span class="nc" id="L294">        log.info(message + &quot; ignored in experimental mode&quot;);</span>
      } else {
<span class="nc" id="L296">        throw new EnforcerRuleException(message);</span>
      }
    }
<span class="nc" id="L299">  }</span>

  public String getCacheId() {
<span class="nc" id="L302">    return null;</span>
  }

  public boolean isCacheable() {
<span class="nc" id="L306">    return false;</span>
  }

  public boolean isResultValid(EnforcerRule arg0) {
<span class="nc" id="L310">    return false;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>