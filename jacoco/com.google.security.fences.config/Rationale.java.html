<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Rationale.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Fences Enforcer Rule</a> &gt; <a href="index.source.html" class="el_package">com.google.security.fences.config</a> &gt; <span class="el_source">Rationale.java</span></div><h1>Rationale.java</h1><pre class="source lang-java linenums">package com.google.security.fences.config;

import java.util.List;

import com.google.common.base.Objects;
import com.google.common.collect.ImmutableList;

import org.apache.maven.enforcer.rule.api.EnforcerRuleException;
import org.codehaus.plexus.interpolation.InterpolationException;
import org.codehaus.plexus.interpolation.RegexBasedInterpolator;
import org.codehaus.plexus.interpolation.ValueSource;


/**
 * Human-readable text explaining the reason for a policy decision.
 */
public final class Rationale {
  /** An {@linkplain #isEmpty empty} instance. */
<span class="fc" id="L19">  public static final Rationale EMPTY = new Rationale(</span>
      HumanReadableText.EMPTY, HumanReadableText.EMPTY);

  /**
   * Human-readable text specifying the reason for a policy decision.
   * &lt;p&gt;
   * These may be overridden by other rationales.  When a &lt;tt&gt;.pom&lt;/tt&gt; file
   * or &lt;tt&gt;META-INF/fences.xml&lt;/tt&gt; file imports another, then its
   * {@code &lt;rationale /&gt;}s clobber any from the imported file on the same
   * API element.
   */
  public final HumanReadableText body;
  /**
   * Human-readable text specifying how to get answers about a policy decision.
   * &lt;p&gt;
   * These are appended to the body to come up with the whole rationale, and
   * addenda are not overridden.
   */
  public final HumanReadableText addendum;

  /** ctor */
<span class="fc" id="L40">  public Rationale(HumanReadableText body, HumanReadableText addendum) {</span>
<span class="fc" id="L41">    this.body = body;</span>
<span class="fc" id="L42">    this.addendum = addendum;</span>
<span class="fc" id="L43">  }</span>

  /** True iff there is no text in this rationale. */
  public boolean isEmpty() {
<span class="nc bnc" id="L47" title="All 4 branches missed.">    return body.isEmpty() &amp;&amp; addendum.isEmpty();</span>
  }

  /**
   * The whole human readable text.
   */
  public HumanReadableText getWholeText() {
<span class="nc" id="L54">    return body.concat(addendum);</span>
  }

  @Override
  public int hashCode() {
<span class="nc" id="L59">    return Objects.hashCode(body, addendum);</span>
  }

  @Override
  public boolean equals(Object o) {
<span class="nc bnc" id="L64" title="All 2 branches missed.">    if (!(o instanceof Rationale)) {</span>
<span class="nc" id="L65">      return false;</span>
    }
<span class="nc" id="L67">    Rationale that = (Rationale) o;</span>
<span class="nc bnc" id="L68" title="All 4 branches missed.">    return this.body.equals(that.body) &amp;&amp; this.addendum.equals(that.addendum);</span>
  }

  /**
   * Mutable builder for {@link Rationale}s.
   */
<span class="fc" id="L74">  public static final class Builder {</span>
    /**
     * Lines of human-readable text specifying the reason for a policy decision.
     * &lt;p&gt;
     * These may be overridden by other rationales.  When a &lt;tt&gt;.pom&lt;/tt&gt; file
     * or &lt;tt&gt;META-INF/fences.xml&lt;/tt&gt; file imports another, then its
     * {@code &lt;rationale /&gt;}s clobber any from the imported file on the same
     * API element.
     */
<span class="fc" id="L83">    private HumanReadableText body = HumanReadableText.EMPTY;</span>
    /**
     * Lines of human-readable text specifying how to get answers about a policy
     * decision.
     * &lt;p&gt;
     * These are appended to the body to come up with the whole rationale, and
     * addenda are not overridden.
     */
<span class="fc" id="L91">    private HumanReadableText addendum = HumanReadableText.EMPTY;</span>

    /**
     * Adds a rationale body parsed from an element in a plexus
     * {@code &lt;configuration /&gt;}.
     * &lt;p&gt;
     * This may be called multiple times, so
     * &lt;pre&gt;
     *   &amp;lt;rationale&amp;gt;line 1&amp;lt;/rationale&amp;gt;
     *   &amp;lt;rationale&amp;gt;line 2&amp;lt;/rationale&amp;gt;
     * &lt;/pre&gt;
     * is equivalent to
     * &lt;pre&gt;
     *   &amp;lt;rationale&amp;gt;
     *     line 1
     *     line 2
     *   &amp;lt;/rationale&amp;gt;
     * &lt;/pre&gt;
     */
    public Builder addBody(String xmlTextNodeContent)
    throws EnforcerRuleException {
<span class="nc" id="L112">      return addBody(HumanReadableText.fromXmlTextNode(xmlTextNodeContent));</span>
    }

    /**
     * Adds text to the body.
     * This concatenates the new body after the previous body.
     *
     * @throws EnforcerRuleException if the concatenated body contains a
     *     malformed Plexus interpolator expression.
     */
    public Builder addBody(HumanReadableText newBody)
    throws EnforcerRuleException {
<span class="nc" id="L124">      body = body.concat(checkInterpolatable(newBody));</span>
<span class="nc" id="L125">      return this;</span>
    }

    /**
     * Concatenates r's body after the body thus far.
     */
    public Builder addBodyFrom(Rationale r) {
      try {
<span class="nc" id="L133">        return addBody(r.body);</span>
<span class="nc" id="L134">      } catch (EnforcerRuleException ex) {</span>
<span class="nc" id="L135">        throw new AssertionError(null, ex);</span>
      }
    }

    /**
     * Replaces this builder's
     */
    public Builder setBodyFrom(Rationale r) {
<span class="nc" id="L143">      this.body = r.body;</span>
<span class="nc" id="L144">      return this;</span>
    }

    /**
     * Adds an addendum parsed from a plexus {@code &lt;configuration /&gt;}.
     * &lt;p&gt;
     * This may be called multiple times, so
     * &lt;pre&gt;
     *   &amp;lt;addendum&amp;gt;line 1&amp;lt;/addendum&amp;gt;
     *   &amp;lt;addendum&amp;gt;line 2&amp;lt;/addendum&amp;gt;
     * &lt;/pre&gt;
     * is equivalent to
     * &lt;pre&gt;
     *   &amp;lt;addendum&amp;gt;
     *     line 1
     *     line 2
     *   &amp;lt;/addendum&amp;gt;
     * &lt;/pre&gt;
     */
    public Builder addAddendum(String xmlTextNodeContent)
    throws EnforcerRuleException {
<span class="nc" id="L165">      return addAddendum(HumanReadableText.fromXmlTextNode(xmlTextNodeContent));</span>
    }

    /**
     * Adds text to the addendum.
     * This concatenates the new addendum after the previous addendum.
     *
     * @throws EnforcerRuleException if the concatenated body contains a
     *     malformed Plexus interpolator expression.
     */
    public Builder addAddendum(HumanReadableText newAddendum)
    throws EnforcerRuleException {
<span class="nc" id="L177">      addendum = addendum.concat(checkInterpolatable(newAddendum));</span>
<span class="nc" id="L178">      return this;</span>
    }

    /**
     * Concatenates r's addendum after the addendum thus far.
     */
    public Builder addAddendumFrom(Rationale r) {
      try {
<span class="nc" id="L186">        return addAddendum(r.addendum);</span>
<span class="nc" id="L187">      } catch (EnforcerRuleException ex) {</span>
<span class="nc" id="L188">        throw new AssertionError(null, ex);</span>
      }
    }

    /** The body so far. */
    public HumanReadableText getBody() {
<span class="fc" id="L194">      return body;</span>
    }

    /** The addendum so far. */
    public HumanReadableText getAddendum() {
<span class="fc" id="L199">      return addendum;</span>
    }

    private static HumanReadableText checkInterpolatable(HumanReadableText t)
    throws EnforcerRuleException {
      // Try to pre-validate it as a valid plexus expression?
<span class="nc" id="L205">      RegexBasedInterpolator interpolator = new RegexBasedInterpolator();</span>
<span class="nc" id="L206">      interpolator.addValueSource(IdentityValueSource.INSTANCE);</span>
      try {
<span class="nc" id="L208">        interpolator.interpolate(t.text);</span>
<span class="nc" id="L209">      } catch (InterpolationException ex) {</span>
<span class="nc" id="L210">        throw new EnforcerRuleException(</span>
            &quot;Malformed property expression in: &quot; + t.text, ex);
<span class="nc" id="L212">      }</span>
<span class="nc" id="L213">      return t;</span>
    }

    /**
     * The immutable instance corresponding to the set of mutating calls thus
     * far.
     */
    public Rationale build() {
<span class="pc bpc" id="L221" title="2 of 4 branches missed.">      if (body.isEmpty() &amp;&amp; addendum.isEmpty()) {</span>
<span class="fc" id="L222">        return Rationale.EMPTY;</span>
      }
<span class="nc" id="L224">      return new Rationale(body, addendum);</span>
    }
  }

  /**
   * Makes a best effort like {@link HumanReadableText#concatDedupe}.
   */
  public static Rationale merge(Rationale a, Rationale b) {
<span class="nc bnc" id="L232" title="All 4 branches missed.">    if (b.isEmpty() || a.equals(b)) { return a; }</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">    if (a.isEmpty()) { return b; }</span>
<span class="nc" id="L234">    return new Rationale(</span>
<span class="nc" id="L235">        a.body.concatDedupe(b.body),</span>
<span class="nc" id="L236">        a.addendum.concatDedupe(b.addendum));</span>
  }
}


final class IdentityValueSource implements ValueSource {
<span class="nc" id="L242">  static final IdentityValueSource INSTANCE = new IdentityValueSource();</span>

<span class="nc" id="L244">  private IdentityValueSource() {</span>
<span class="nc" id="L245">  }</span>

  public void clearFeedback() {
    // Nothing to do.
<span class="nc" id="L249">  }</span>

  @SuppressWarnings(&quot;rawtypes&quot;)
  public List getFeedback() {
<span class="nc" id="L253">    return ImmutableList.of();</span>
  }

  public Object getValue(String key) {
<span class="nc" id="L257">    return key;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>