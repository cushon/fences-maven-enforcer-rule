<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ClassNode.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Fences Enforcer Rule</a> &gt; <a href="index.source.html" class="el_package">com.google.security.fences.inheritance</a> &gt; <span class="el_source">ClassNode.java</span></div><h1>ClassNode.java</h1><pre class="source lang-java linenums">package com.google.security.fences.inheritance;

import org.objectweb.asm.Opcodes;

import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;

/**
 * A node in the inheritance graph.
 */
public final class ClassNode implements Comparable&lt;ClassNode&gt; {
  /**
   * The internal class name of the class post inner-class to top-level
   * conversion.
   * Internal class names have the form {@code com/example/Outer$Inner}, not
   * dotted fully-qualified names.
   */
  public final String name;
  /**
   * A bitfield of {@link Opcodes}.ACC_* constants.
   */
  public final int access;
  /**
   * The internal name of the super-type if any.  {@code java.lang.Object} does
   * not have a super-type.
   * ASM treats interfaces as having super-type {@code java.lang.Object}.
   */
  public final Optional&lt;String&gt; superType;
  /**
   * The internal name of the outer-class if any.
   */
  public final Optional&lt;String&gt; outerClass;
  /**
   * For classes, the internal names of interfaces it {@code implements}, and
   * for interfaces the interfaces it {@code extends}.
   */
  public final ImmutableList&lt;String&gt; interfaces;
  /**
   * Names and signatures of declared methods.
   */
  public final ImmutableSet&lt;MethodDetails&gt; methods;
  /**
   * Names of declared fields.
   */
  public final ImmutableSet&lt;FieldDetails&gt; fields;

  ClassNode(
      String name,
      int access,
      Optional&lt;String&gt; superType,
      Optional&lt;String&gt; outerClass,
      Iterable&lt;? extends String&gt; interfaces,
      Iterable&lt;? extends MethodDetails&gt; methods,
<span class="fc" id="L56">      Iterable&lt;? extends FieldDetails&gt; fields) {</span>
    // Names should be of form com/example/Name, not com.example.Name.
<span class="pc bpc" id="L58" title="1 of 2 branches missed.">    Preconditions.checkArgument(!name.contains(&quot;.&quot;), name);</span>
<span class="fc" id="L59">    this.name = name;</span>
<span class="fc" id="L60">    this.access = access;</span>
<span class="fc" id="L61">    this.superType = superType;</span>
<span class="fc" id="L62">    this.outerClass = outerClass;</span>
<span class="fc" id="L63">    this.interfaces = ImmutableList.copyOf(interfaces);</span>
<span class="fc" id="L64">    this.methods = ImmutableSet.copyOf(methods);</span>
<span class="fc" id="L65">    this.fields = ImmutableSet.copyOf(fields);</span>
<span class="fc" id="L66">  }</span>

  /**
   * The method with the given name and descriptor if any.
   */
  public Optional&lt;MethodDetails&gt; getMethod(
      String methodName, String descriptor) {
<span class="fc bfc" id="L73" title="All 2 branches covered.">    for (MethodDetails m : methods) {</span>
<span class="pc bpc" id="L74" title="1 of 4 branches missed.">      if (m.name.equals(methodName) &amp;&amp; m.desc.equals(descriptor)) {</span>
<span class="fc" id="L75">        return Optional.of(m);</span>
      }
<span class="fc" id="L77">    }</span>
<span class="fc" id="L78">    return Optional.absent();</span>
  }

  /**
   * The field with the given name if any.
   */
  public Optional&lt;FieldDetails&gt; getField(String fieldName) {
<span class="fc bfc" id="L85" title="All 2 branches covered.">    for (FieldDetails f : fields) {</span>
<span class="fc bfc" id="L86" title="All 2 branches covered.">      if (f.name.equals(fieldName)) {</span>
<span class="fc" id="L87">        return Optional.of(f);</span>
      }
<span class="fc" id="L89">    }</span>
<span class="fc" id="L90">    return Optional.absent();</span>
  }

  /**
   * True if a method with the given name and descriptor is visible from
   * a super-type through this type.
   * In other words, there is no compatible method declaration that would
   * prevent a sub-type from inheriting the method from a super-type.
   *
   * @param methodName the name of a method available on this class.
   * @param descriptor the Java internal descriptor consisting of the
   *     parameter types in order in parentheses followed by the return type.
   */
  public boolean isMethodVisibleThrough(String methodName, String descriptor) {
<span class="fc bfc" id="L104" title="All 2 branches covered.">    for (MethodDetails m : methods) {</span>
      // Method return-type specialization and generic parameter specialization
      // do not affect descriptors because javac creates two methods --
      // the specialized version and an unspecialized version that calls the
      // former.
<span class="pc bpc" id="L109" title="2 of 6 branches missed.">      if (m.name.equals(methodName) &amp;&amp; m.desc.equals(descriptor)</span>
          &amp;&amp; (m.access &amp; Opcodes.ACC_PRIVATE) == 0) {
<span class="fc" id="L111">        return false;</span>
      }
<span class="fc" id="L113">    }</span>
<span class="fc" id="L114">    return true;</span>
  }

  /**
   * True if the named field is visible from a super-type through this type.
   * In other words, there is no masking field declaration in this class visible
   * to sub-types.
   */
  public boolean isFieldVisibleThrough(String fieldName) {
<span class="fc bfc" id="L123" title="All 2 branches covered.">    for (FieldDetails f : fields) {</span>
<span class="fc bfc" id="L124" title="All 4 branches covered.">      if (f.name.equals(fieldName)</span>
          // Private fields do not mask fields in super-tpes.
          &amp;&amp; (f.access &amp; Opcodes.ACC_PRIVATE) == 0) {
<span class="fc" id="L127">        return false;</span>
      }
<span class="fc" id="L129">    }</span>
<span class="fc" id="L130">    return true;</span>
  }

  public int compareTo(ClassNode x) {
<span class="nc" id="L134">    return name.compareTo(x.name);</span>
  }

  @Override
  public boolean equals(Object o) {
<span class="nc bnc" id="L139" title="All 2 branches missed.">    if (!(o instanceof ClassNode)) {</span>
<span class="nc" id="L140">      return false;</span>
    }
<span class="nc" id="L142">    ClassNode that = (ClassNode) o;</span>
<span class="nc" id="L143">    return this.name.equals(that.name);  // Consistent with compare</span>
  }

  @Override
  public int hashCode() {
<span class="nc" id="L148">    return name.hashCode();</span>
  }

  @Override
  public String toString() {
<span class="nc" id="L153">    return name;</span>
  }
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>